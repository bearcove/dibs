// @generated by roam-codegen
// DO NOT EDIT - regenerate with `cargo xtask codegen --typescript`

import type { MethodHandler, Connection, MessageTransport, DecodeResult, MethodSchema, Caller } from "@bearcove/roam-core";
import {
  encodeResultOk, encodeResultErr, encodeInvalidPayload,
  concat, encodeVarint, decodeVarintNumber, decodeRpcResult,
  encodeWithSchema, decodeWithSchema,
  encodeBool, decodeBool,
  encodeU8, decodeU8, encodeI8, decodeI8,
  encodeU16, decodeU16, encodeI16, decodeI16,
  encodeU32, decodeU32, encodeI32, decodeI32,
  encodeU64, decodeU64, encodeI64, decodeI64,
  encodeF32, decodeF32, encodeF64, decodeF64,
  encodeString, decodeString,
  encodeBytes, decodeBytes,
  encodeOption, decodeOption,
  encodeVec, decodeVec,
  encodeTuple2, decodeTuple2, encodeTuple3, decodeTuple3,
  encodeEnumVariant, decodeEnumVariant,
  helloExchangeInitiator, defaultHello,
  CallBuilder,
} from "@bearcove/roam-core";
import { connectWs, type WsTransport } from "@bearcove/roam-ws";
import { RpcError } from "@bearcove/roam-core";

export const METHOD_ID = {
  schema: 0xf0694b64f25d44ffn,
  list: 0xf4944ea4d9e891c1n,
  get: 0x1b8a7ad7106234c6n,
  create: 0x8ab9f5d104a6718en,
  update: 0xce45c093f47db097n,
  delete: 0x9e3f878d91c08d03n,
} as const;

// Named type definitions
export interface ColumnInfo {
  name: string;
  sql_type: string;
  rust_type: string | null;
  nullable: boolean;
  default: string | null;
  primary_key: boolean;
  unique: boolean;
  auto_generated: boolean;
  long: boolean;
  label: boolean;
  enum_variants: string[];
  doc: string | null;
  lang: string | null;
  icon: string | null;
  subtype: string | null;
}

export interface ForeignKeyInfo {
  columns: string[];
  references_table: string;
  references_columns: string[];
}

export interface IndexColumnInfo {
  name: string;
  order: string;
  nulls: string;
}

export interface IndexInfo {
  name: string;
  columns: IndexColumnInfo[];
  unique: boolean;
  where_clause: string | null;
}

export interface TableInfo {
  name: string;
  columns: ColumnInfo[];
  foreign_keys: ForeignKeyInfo[];
  indices: IndexInfo[];
  source_file: string | null;
  source_line: number | null;
  doc: string | null;
  icon: string | null;
}

export interface SchemaInfo {
  tables: TableInfo[];
}

export type FilterOp =
  | { tag: 'Eq' }
  | { tag: 'Ne' }
  | { tag: 'Lt' }
  | { tag: 'Lte' }
  | { tag: 'Gt' }
  | { tag: 'Gte' }
  | { tag: 'Like' }
  | { tag: 'ILike' }
  | { tag: 'IsNull' }
  | { tag: 'IsNotNull' }
  | { tag: 'In' }
  | { tag: 'JsonGet' }
  | { tag: 'JsonGetText' }
  | { tag: 'Contains' }
  | { tag: 'KeyExists' };

export type Value =
  | { tag: 'Null' }
  | { tag: 'Bool'; value: boolean }
  | { tag: 'I16'; value: number }
  | { tag: 'I32'; value: number }
  | { tag: 'I64'; value: bigint }
  | { tag: 'F32'; value: number }
  | { tag: 'F64'; value: number }
  | { tag: 'String'; value: string }
  | { tag: 'Bytes'; value: Uint8Array };

export interface Filter {
  field: string;
  op: FilterOp;
  value: Value;
  values: Value[];
}

export type SortDir =
  | { tag: 'Asc' }
  | { tag: 'Desc' };

export interface Sort {
  field: string;
  dir: SortDir;
}

export interface ListRequest {
  table: string;
  filters: Filter[];
  sort: Sort[];
  limit: number | null;
  offset: number | null;
  select: string[];
}

export interface RowField {
  name: string;
  value: Value;
}

export interface Row {
  fields: RowField[];
}

export interface ListResponse {
  rows: Row[];
  total: bigint | null;
}

export interface SqlError {
  message: string;
  sql: string | null;
  position: number | null;
  hint: string | null;
  detail: string | null;
  caller: string | null;
}

export type DibsError =
  | { tag: 'ConnectionFailed'; value: string }
  | { tag: 'MigrationFailed'; value: SqlError }
  | { tag: 'InvalidRequest'; value: string }
  | { tag: 'UnknownTable'; value: string }
  | { tag: 'UnknownColumn'; value: string }
  | { tag: 'QueryError'; value: string };

export interface GetRequest {
  table: string;
  pk: Value;
}

export interface CreateRequest {
  table: string;
  data: Row;
}

export interface UpdateRequest {
  table: string;
  pk: Value;
  data: Row;
}

export interface DeleteRequest {
  table: string;
  pk: Value;
}

// Request/Response type aliases
export type SchemaRequest = [];
export type SchemaResponse = SchemaInfo;


export type GetResponse = { ok: true; value: Row | null } | { ok: false; error: DibsError };

export type CreateResponse = { ok: true; value: Row } | { ok: false; error: DibsError };

export type UpdateResponse = { ok: true; value: Row } | { ok: false; error: DibsError };

export type DeleteResponse = { ok: true; value: bigint } | { ok: false; error: DibsError };

// Caller interface for SquelService
export interface SquelServiceCaller {
  /** Get the schema for all registered tables. */
  schema(): CallBuilder<SchemaInfo>;
  /** List rows from a table with filtering, sorting, and pagination. */
  list(request: ListRequest): CallBuilder<{ ok: true; value: ListResponse } | { ok: false; error: DibsError }>;
  /** Get a single row by primary key. */
  get(request: GetRequest): CallBuilder<{ ok: true; value: Row | null } | { ok: false; error: DibsError }>;
  /** Create a new row. */
  create(request: CreateRequest): CallBuilder<{ ok: true; value: Row } | { ok: false; error: DibsError }>;
  /** Update an existing row. */
  update(request: UpdateRequest): CallBuilder<{ ok: true; value: Row } | { ok: false; error: DibsError }>;
  /** Delete a row. */
  delete(request: DeleteRequest): CallBuilder<{ ok: true; value: bigint } | { ok: false; error: DibsError }>;
}

// Client implementation for SquelService
export class SquelServiceClient implements SquelServiceCaller {
  private caller: Caller;

  constructor(caller: Caller) {
    this.caller = caller;
  }

  /** Get the schema for all registered tables. */
  schema(): CallBuilder<SchemaInfo> {
    const schema = squelService_schemas.schema;
    return new CallBuilder(async (metadata) => {
      const response = await this.caller.call({
        methodId: 0xf0694b64f25d44ffn,
        method: "SquelService.schema",
        args: {},
        encode: (_a: Record<string, unknown>) => new Uint8Array(0),
        metadata,
      });
      const offset = decodeRpcResult(response, 0);
      const result = decodeWithSchema(response, offset, schema.returns).value;
      return result as SchemaInfo;
    });
  }

  /** List rows from a table with filtering, sorting, and pagination. */
  list(request: ListRequest): CallBuilder<{ ok: true; value: ListResponse } | { ok: false; error: DibsError }> {
    const schema = squelService_schemas.list;
    return new CallBuilder(async (metadata) => {
      const response = await this.caller.call({
        methodId: 0xf4944ea4d9e891c1n,
        method: "SquelService.list",
        args: { request },
        encode: (a: Record<string, unknown>) => encodeWithSchema(a.request, schema.args[0]),
        metadata,
      });
      try {
        const offset = decodeRpcResult(response, 0);
        const value = decodeWithSchema(response, offset, schema.returns).value;
        return { ok: true, value } as { ok: true; value: ListResponse } | { ok: false; error: DibsError };
      } catch (e) {
        if (e instanceof RpcError && e.isUserError() && e.payload && schema.error) {
          const error = decodeWithSchema(e.payload, 0, schema.error).value;
          return { ok: false, error } as { ok: true; value: ListResponse } | { ok: false; error: DibsError };
        }
        throw e;
      }
    });
  }

  /** Get a single row by primary key. */
  get(request: GetRequest): CallBuilder<{ ok: true; value: Row | null } | { ok: false; error: DibsError }> {
    const schema = squelService_schemas.get;
    return new CallBuilder(async (metadata) => {
      const response = await this.caller.call({
        methodId: 0x1b8a7ad7106234c6n,
        method: "SquelService.get",
        args: { request },
        encode: (a: Record<string, unknown>) => encodeWithSchema(a.request, schema.args[0]),
        metadata,
      });
      try {
        const offset = decodeRpcResult(response, 0);
        const value = decodeWithSchema(response, offset, schema.returns).value;
        return { ok: true, value } as { ok: true; value: Row | null } | { ok: false; error: DibsError };
      } catch (e) {
        if (e instanceof RpcError && e.isUserError() && e.payload && schema.error) {
          const error = decodeWithSchema(e.payload, 0, schema.error).value;
          return { ok: false, error } as { ok: true; value: Row | null } | { ok: false; error: DibsError };
        }
        throw e;
      }
    });
  }

  /** Create a new row. */
  create(request: CreateRequest): CallBuilder<{ ok: true; value: Row } | { ok: false; error: DibsError }> {
    const schema = squelService_schemas.create;
    return new CallBuilder(async (metadata) => {
      const response = await this.caller.call({
        methodId: 0x8ab9f5d104a6718en,
        method: "SquelService.create",
        args: { request },
        encode: (a: Record<string, unknown>) => encodeWithSchema(a.request, schema.args[0]),
        metadata,
      });
      try {
        const offset = decodeRpcResult(response, 0);
        const value = decodeWithSchema(response, offset, schema.returns).value;
        return { ok: true, value } as { ok: true; value: Row } | { ok: false; error: DibsError };
      } catch (e) {
        if (e instanceof RpcError && e.isUserError() && e.payload && schema.error) {
          const error = decodeWithSchema(e.payload, 0, schema.error).value;
          return { ok: false, error } as { ok: true; value: Row } | { ok: false; error: DibsError };
        }
        throw e;
      }
    });
  }

  /** Update an existing row. */
  update(request: UpdateRequest): CallBuilder<{ ok: true; value: Row } | { ok: false; error: DibsError }> {
    const schema = squelService_schemas.update;
    return new CallBuilder(async (metadata) => {
      const response = await this.caller.call({
        methodId: 0xce45c093f47db097n,
        method: "SquelService.update",
        args: { request },
        encode: (a: Record<string, unknown>) => encodeWithSchema(a.request, schema.args[0]),
        metadata,
      });
      try {
        const offset = decodeRpcResult(response, 0);
        const value = decodeWithSchema(response, offset, schema.returns).value;
        return { ok: true, value } as { ok: true; value: Row } | { ok: false; error: DibsError };
      } catch (e) {
        if (e instanceof RpcError && e.isUserError() && e.payload && schema.error) {
          const error = decodeWithSchema(e.payload, 0, schema.error).value;
          return { ok: false, error } as { ok: true; value: Row } | { ok: false; error: DibsError };
        }
        throw e;
      }
    });
  }

  /** Delete a row. */
  delete(request: DeleteRequest): CallBuilder<{ ok: true; value: bigint } | { ok: false; error: DibsError }> {
    const schema = squelService_schemas.delete;
    return new CallBuilder(async (metadata) => {
      const response = await this.caller.call({
        methodId: 0x9e3f878d91c08d03n,
        method: "SquelService.delete",
        args: { request },
        encode: (a: Record<string, unknown>) => encodeWithSchema(a.request, schema.args[0]),
        metadata,
      });
      try {
        const offset = decodeRpcResult(response, 0);
        const value = decodeWithSchema(response, offset, schema.returns).value;
        return { ok: true, value } as { ok: true; value: bigint } | { ok: false; error: DibsError };
      } catch (e) {
        if (e instanceof RpcError && e.isUserError() && e.payload && schema.error) {
          const error = decodeWithSchema(e.payload, 0, schema.error).value;
          return { ok: false, error } as { ok: true; value: bigint } | { ok: false; error: DibsError };
        }
        throw e;
      }
    });
  }

}

/**
 * Connect to a SquelService server over WebSocket.
 * @param url - WebSocket URL (e.g., "ws://localhost:9000")
 * @returns A connected SquelServiceClient instance
 */
export async function connectSquelService(url: string): Promise<SquelServiceClient> {
  const transport = await connectWs(url);
  const connection = await helloExchangeInitiator(transport, defaultHello());
  return new SquelServiceClient(connection.asCaller());
}

// Handler interface for SquelService
export interface SquelServiceHandler {
  schema(): Promise<SchemaInfo> | SchemaInfo;
  list(request: ListRequest): Promise<{ ok: true; value: ListResponse } | { ok: false; error: DibsError }> | { ok: true; value: ListResponse } | { ok: false; error: DibsError };
  get(request: GetRequest): Promise<{ ok: true; value: Row | null } | { ok: false; error: DibsError }> | { ok: true; value: Row | null } | { ok: false; error: DibsError };
  create(request: CreateRequest): Promise<{ ok: true; value: Row } | { ok: false; error: DibsError }> | { ok: true; value: Row } | { ok: false; error: DibsError };
  update(request: UpdateRequest): Promise<{ ok: true; value: Row } | { ok: false; error: DibsError }> | { ok: true; value: Row } | { ok: false; error: DibsError };
  delete(request: DeleteRequest): Promise<{ ok: true; value: bigint } | { ok: false; error: DibsError }> | { ok: true; value: bigint } | { ok: false; error: DibsError };
}

// Method handlers for SquelService
export const squelService_methodHandlers = new Map<bigint, MethodHandler<SquelServiceHandler>>([
  [0xf0694b64f25d44ffn, async (handler, payload) => {
    try {
      const buf = payload;
      let offset = 0;
      if (offset !== buf.length) throw new Error("args: trailing bytes");
      const result = await handler.schema();
      return encodeResultOk(concat(encodeVec(result.tables, (item) => concat(encodeString(item.name), encodeVec(item.columns, (item) => concat(encodeString(item.name), encodeString(item.sql_type), encodeOption(item.rust_type, (v) => encodeString(v)), encodeBool(item.nullable), encodeOption(item.default, (v) => encodeString(v)), encodeBool(item.primary_key), encodeBool(item.unique), encodeBool(item.auto_generated), encodeBool(item.long), encodeBool(item.label), encodeVec(item.enum_variants, (item) => encodeString(item)), encodeOption(item.doc, (v) => encodeString(v)), encodeOption(item.lang, (v) => encodeString(v)), encodeOption(item.icon, (v) => encodeString(v)), encodeOption(item.subtype, (v) => encodeString(v)))), encodeVec(item.foreign_keys, (item) => concat(encodeVec(item.columns, (item) => encodeString(item)), encodeString(item.references_table), encodeVec(item.references_columns, (item) => encodeString(item)))), encodeVec(item.indices, (item) => concat(encodeString(item.name), encodeVec(item.columns, (item) => concat(encodeString(item.name), encodeString(item.order), encodeString(item.nulls))), encodeBool(item.unique), encodeOption(item.where_clause, (v) => encodeString(v)))), encodeOption(item.source_file, (v) => encodeString(v)), encodeOption(item.source_line, (v) => encodeU32(v)), encodeOption(item.doc, (v) => encodeString(v)), encodeOption(item.icon, (v) => encodeString(v))))));
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0xf4944ea4d9e891c1n, async (handler, payload) => {
    try {
      // Channeling method - use streamingDispatch() instead of simple RPC dispatch
      return encodeResultErr(encodeInvalidPayload());
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x1b8a7ad7106234c6n, async (handler, payload) => {
    try {
      // Channeling method - use streamingDispatch() instead of simple RPC dispatch
      return encodeResultErr(encodeInvalidPayload());
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x8ab9f5d104a6718en, async (handler, payload) => {
    try {
      // Channeling method - use streamingDispatch() instead of simple RPC dispatch
      return encodeResultErr(encodeInvalidPayload());
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0xce45c093f47db097n, async (handler, payload) => {
    try {
      // Channeling method - use streamingDispatch() instead of simple RPC dispatch
      return encodeResultErr(encodeInvalidPayload());
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
  [0x9e3f878d91c08d03n, async (handler, payload) => {
    try {
      // Channeling method - use streamingDispatch() instead of simple RPC dispatch
      return encodeResultErr(encodeInvalidPayload());
    } catch (e) {
      return encodeResultErr(encodeInvalidPayload());
    }
  }],
]);

// Method schemas for runtime encoding/decoding and channel binding
export const squelService_schemas: Record<string, MethodSchema> = {
  schema: { args: [], returns: { kind: 'struct', fields: { 'tables': { kind: 'vec', element: { kind: 'struct', fields: { 'name': { kind: 'string' }, 'columns': { kind: 'vec', element: { kind: 'struct', fields: { 'name': { kind: 'string' }, 'sql_type': { kind: 'string' }, 'rust_type': { kind: 'option', inner: { kind: 'string' } }, 'nullable': { kind: 'bool' }, 'default': { kind: 'option', inner: { kind: 'string' } }, 'primary_key': { kind: 'bool' }, 'unique': { kind: 'bool' }, 'auto_generated': { kind: 'bool' }, 'long': { kind: 'bool' }, 'label': { kind: 'bool' }, 'enum_variants': { kind: 'vec', element: { kind: 'string' } }, 'doc': { kind: 'option', inner: { kind: 'string' } }, 'lang': { kind: 'option', inner: { kind: 'string' } }, 'icon': { kind: 'option', inner: { kind: 'string' } }, 'subtype': { kind: 'option', inner: { kind: 'string' } } } } }, 'foreign_keys': { kind: 'vec', element: { kind: 'struct', fields: { 'columns': { kind: 'vec', element: { kind: 'string' } }, 'references_table': { kind: 'string' }, 'references_columns': { kind: 'vec', element: { kind: 'string' } } } } }, 'indices': { kind: 'vec', element: { kind: 'struct', fields: { 'name': { kind: 'string' }, 'columns': { kind: 'vec', element: { kind: 'struct', fields: { 'name': { kind: 'string' }, 'order': { kind: 'string' }, 'nulls': { kind: 'string' } } } }, 'unique': { kind: 'bool' }, 'where_clause': { kind: 'option', inner: { kind: 'string' } } } } }, 'source_file': { kind: 'option', inner: { kind: 'string' } }, 'source_line': { kind: 'option', inner: { kind: 'u32' } }, 'doc': { kind: 'option', inner: { kind: 'string' } }, 'icon': { kind: 'option', inner: { kind: 'string' } } } } } } }, error: null },
  list: { args: [{ kind: 'struct', fields: { 'table': { kind: 'string' }, 'filters': { kind: 'vec', element: { kind: 'struct', fields: { 'field': { kind: 'string' }, 'op': { kind: 'enum', variants: [{ name: 'Eq', fields: null }, { name: 'Ne', fields: null }, { name: 'Lt', fields: null }, { name: 'Lte', fields: null }, { name: 'Gt', fields: null }, { name: 'Gte', fields: null }, { name: 'Like', fields: null }, { name: 'ILike', fields: null }, { name: 'IsNull', fields: null }, { name: 'IsNotNull', fields: null }, { name: 'In', fields: null }, { name: 'JsonGet', fields: null }, { name: 'JsonGetText', fields: null }, { name: 'Contains', fields: null }, { name: 'KeyExists', fields: null }] }, 'value': { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] }, 'values': { kind: 'vec', element: { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] } } } } }, 'sort': { kind: 'vec', element: { kind: 'struct', fields: { 'field': { kind: 'string' }, 'dir': { kind: 'enum', variants: [{ name: 'Asc', fields: null }, { name: 'Desc', fields: null }] } } } }, 'limit': { kind: 'option', inner: { kind: 'u32' } }, 'offset': { kind: 'option', inner: { kind: 'u32' } }, 'select': { kind: 'vec', element: { kind: 'string' } } } }], returns: { kind: 'struct', fields: { 'rows': { kind: 'vec', element: { kind: 'struct', fields: { 'fields': { kind: 'vec', element: { kind: 'struct', fields: { 'name': { kind: 'string' }, 'value': { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] } } } } } } }, 'total': { kind: 'option', inner: { kind: 'u64' } } } }, error: { kind: 'enum', variants: [{ name: 'ConnectionFailed', fields: { kind: 'string' } }, { name: 'MigrationFailed', fields: { kind: 'struct', fields: { 'message': { kind: 'string' }, 'sql': { kind: 'option', inner: { kind: 'string' } }, 'position': { kind: 'option', inner: { kind: 'u32' } }, 'hint': { kind: 'option', inner: { kind: 'string' } }, 'detail': { kind: 'option', inner: { kind: 'string' } }, 'caller': { kind: 'option', inner: { kind: 'string' } } } } }, { name: 'InvalidRequest', fields: { kind: 'string' } }, { name: 'UnknownTable', fields: { kind: 'string' } }, { name: 'UnknownColumn', fields: { kind: 'string' } }, { name: 'QueryError', fields: { kind: 'string' } }] } },
  get: { args: [{ kind: 'struct', fields: { 'table': { kind: 'string' }, 'pk': { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] } } }], returns: { kind: 'option', inner: { kind: 'struct', fields: { 'fields': { kind: 'vec', element: { kind: 'struct', fields: { 'name': { kind: 'string' }, 'value': { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] } } } } } } }, error: { kind: 'enum', variants: [{ name: 'ConnectionFailed', fields: { kind: 'string' } }, { name: 'MigrationFailed', fields: { kind: 'struct', fields: { 'message': { kind: 'string' }, 'sql': { kind: 'option', inner: { kind: 'string' } }, 'position': { kind: 'option', inner: { kind: 'u32' } }, 'hint': { kind: 'option', inner: { kind: 'string' } }, 'detail': { kind: 'option', inner: { kind: 'string' } }, 'caller': { kind: 'option', inner: { kind: 'string' } } } } }, { name: 'InvalidRequest', fields: { kind: 'string' } }, { name: 'UnknownTable', fields: { kind: 'string' } }, { name: 'UnknownColumn', fields: { kind: 'string' } }, { name: 'QueryError', fields: { kind: 'string' } }] } },
  create: { args: [{ kind: 'struct', fields: { 'table': { kind: 'string' }, 'data': { kind: 'struct', fields: { 'fields': { kind: 'vec', element: { kind: 'struct', fields: { 'name': { kind: 'string' }, 'value': { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] } } } } } } } }], returns: { kind: 'struct', fields: { 'fields': { kind: 'vec', element: { kind: 'struct', fields: { 'name': { kind: 'string' }, 'value': { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] } } } } } }, error: { kind: 'enum', variants: [{ name: 'ConnectionFailed', fields: { kind: 'string' } }, { name: 'MigrationFailed', fields: { kind: 'struct', fields: { 'message': { kind: 'string' }, 'sql': { kind: 'option', inner: { kind: 'string' } }, 'position': { kind: 'option', inner: { kind: 'u32' } }, 'hint': { kind: 'option', inner: { kind: 'string' } }, 'detail': { kind: 'option', inner: { kind: 'string' } }, 'caller': { kind: 'option', inner: { kind: 'string' } } } } }, { name: 'InvalidRequest', fields: { kind: 'string' } }, { name: 'UnknownTable', fields: { kind: 'string' } }, { name: 'UnknownColumn', fields: { kind: 'string' } }, { name: 'QueryError', fields: { kind: 'string' } }] } },
  update: { args: [{ kind: 'struct', fields: { 'table': { kind: 'string' }, 'pk': { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] }, 'data': { kind: 'struct', fields: { 'fields': { kind: 'vec', element: { kind: 'struct', fields: { 'name': { kind: 'string' }, 'value': { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] } } } } } } } }], returns: { kind: 'struct', fields: { 'fields': { kind: 'vec', element: { kind: 'struct', fields: { 'name': { kind: 'string' }, 'value': { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] } } } } } }, error: { kind: 'enum', variants: [{ name: 'ConnectionFailed', fields: { kind: 'string' } }, { name: 'MigrationFailed', fields: { kind: 'struct', fields: { 'message': { kind: 'string' }, 'sql': { kind: 'option', inner: { kind: 'string' } }, 'position': { kind: 'option', inner: { kind: 'u32' } }, 'hint': { kind: 'option', inner: { kind: 'string' } }, 'detail': { kind: 'option', inner: { kind: 'string' } }, 'caller': { kind: 'option', inner: { kind: 'string' } } } } }, { name: 'InvalidRequest', fields: { kind: 'string' } }, { name: 'UnknownTable', fields: { kind: 'string' } }, { name: 'UnknownColumn', fields: { kind: 'string' } }, { name: 'QueryError', fields: { kind: 'string' } }] } },
  delete: { args: [{ kind: 'struct', fields: { 'table': { kind: 'string' }, 'pk': { kind: 'enum', variants: [{ name: 'Null', fields: null }, { name: 'Bool', fields: { kind: 'bool' } }, { name: 'I16', fields: { kind: 'i16' } }, { name: 'I32', fields: { kind: 'i32' } }, { name: 'I64', fields: { kind: 'i64' } }, { name: 'F32', fields: { kind: 'f32' } }, { name: 'F64', fields: { kind: 'f64' } }, { name: 'String', fields: { kind: 'string' } }, { name: 'Bytes', fields: { kind: 'bytes' } }] } } }], returns: { kind: 'u64' }, error: { kind: 'enum', variants: [{ name: 'ConnectionFailed', fields: { kind: 'string' } }, { name: 'MigrationFailed', fields: { kind: 'struct', fields: { 'message': { kind: 'string' }, 'sql': { kind: 'option', inner: { kind: 'string' } }, 'position': { kind: 'option', inner: { kind: 'u32' } }, 'hint': { kind: 'option', inner: { kind: 'string' } }, 'detail': { kind: 'option', inner: { kind: 'string' } }, 'caller': { kind: 'option', inner: { kind: 'string' } } } } }, { name: 'InvalidRequest', fields: { kind: 'string' } }, { name: 'UnknownTable', fields: { kind: 'string' } }, { name: 'UnknownColumn', fields: { kind: 'string' } }, { name: 'QueryError', fields: { kind: 'string' } }] } },
};

